From 45b83c2c56bdd5bb2b66a40fbada147c01928130 Mon Sep 17 00:00:00 2001
From: Francisco Ferrari Bihurriet <fferrari@openjdk.org>
Date: Fri, 28 Jun 2024 20:00:23 +0200
Subject: [PATCH] 8320548: Improved loop handling

Reviewed-by: mbalao, andrew
Backport-of: 72eed2f709caa48c82f58fe75c7e94d2c45947e1

Cherry-pick upstream commit-id: 45b83c2c56bdd5bb2b66a40fbada147c01928130

Orabug: 36904352

Signed-off-by: Sourav Sharma <sourav.ss.sharma@oracle.com>
Reviewed-by: Laurence Rochfort <laurence.rochfort@oracle.com>

diff -up openjdk/hotspot/src/share/vm/opto/superword.cpp.orig openjdk/hotspot/src/share/vm/opto/superword.cpp
--- openjdk/hotspot/src/share/vm/opto/superword.cpp.orig	2024-08-23 18:21:49.885306296 +0000
+++ openjdk/hotspot/src/share/vm/opto/superword.cpp	2024-08-23 18:28:32.371306296 +0000
@@ -2187,20 +2187,40 @@ void SuperWord::align_initial_loop_index
   _igvn.register_new_node_with_optimizer(N);
   _phase->set_ctrl(N, pre_ctrl);
 
+  // The computation of the new pre-loop limit could overflow or underflow the int range. This is problematic in
+  // combination with Range Check Elimination (RCE), which determines a "safe" range where a RangeCheck will always
+  // succeed. RCE adjusts the pre-loop limit such that we only enter the main-loop once we have reached the "safe"
+  // range, and adjusts the main-loop limit so that we exit the main-loop before we leave the "safe" range. After RCE,
+  // the range of the main-loop can only be safely narrowed, and should never be widened. Hence, the pre-loop limit
+  // can only be increased (for stride > 0), but an add overflow might decrease it, or decreased (for stride < 0), but
+  // a sub underflow might increase it. To prevent that, we perform the Sub / Add and Max / Min with long operations.
+  lim0       = new (_phase->C) ConvI2LNode(lim0);
+  N          = new (_phase->C) ConvI2LNode(N);
+  orig_limit = new (_phase->C) ConvI2LNode(orig_limit);
+  _igvn.register_new_node_with_optimizer(lim0);
+  _igvn.register_new_node_with_optimizer(N);
+  _igvn.register_new_node_with_optimizer(orig_limit);
+
   //   substitute back into (1), so that new limit
   //     lim = lim0 + N
   Node* lim;
   if (stride < 0) {
-    lim = new (_phase->C) SubINode(lim0, N);
+    lim = new (_phase->C) SubLNode(lim0, N);
   } else {
-    lim = new (_phase->C) AddINode(lim0, N);
+    lim = new (_phase->C) AddLNode(lim0, N);
   }
   _igvn.register_new_node_with_optimizer(lim);
   _phase->set_ctrl(lim, pre_ctrl);
   Node* constrained =
-    (stride > 0) ? (Node*) new (_phase->C) MinINode(lim, orig_limit)
-                 : (Node*) new (_phase->C) MaxINode(lim, orig_limit);
+    (stride > 0) ? (Node*) new (_phase->C) MinLNode(_phase->C, lim, orig_limit)
+                 : (Node*) new (_phase->C) MaxLNode(_phase->C, lim, orig_limit);
+  _igvn.register_new_node_with_optimizer(constrained);
+
+
+  // We know that the result is in the int range, there is never truncation
+  constrained = new (_phase->C) ConvL2INode(constrained);
   _igvn.register_new_node_with_optimizer(constrained);
+  
   _phase->set_ctrl(constrained, pre_ctrl);
   _igvn.hash_delete(pre_opaq);
   pre_opaq->set_req(1, constrained);
